#!/usr/bin/env php
<?php

// Find and initialize Composer
$files = array(
    __DIR__ . '/../../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
    __DIR__ . '/../../../../autoload.php',
    __DIR__ . '/../vendor/autoload.php',
);

foreach ($files as $file) {
    if (file_exists($file)) {
        require_once $file;
        break;
    }
}

if (!class_exists('Composer\Autoload\ClassLoader', false)) {
	$RESQUE_PATH = getenv('RESQUE_PATH');
	if($RESQUE_PATH) {
		if(!file_exists("${RESQUE_PATH}/Resque.php") && !file_exists("${RESQUE_PATH}/lib/Resque.php")) {
			die('RESQUE_PATH ('.$RESQUE_PATH.") is incorrect - it should point to the directory containing Resque.php.\n");
		}
		elseif(file_exists("${RESQUE_PATH}/lib/Resque.php")) {
			$RESQUE_PATH = "${RESQUE_PATH}/lib";
		}
	}
	else
	{
		$dirs = array(
			__DIR__ . '/../lib',
			__DIR__ . '/lib',
			__DIR__ . '/php-resque/lib',
			__DIR__ . '/../php-resque/lib',
			__DIR__ . '/../../chrisboulton/php-resque/lib',
			__DIR__ . '/vendor/chrisboulton/php-resque/lib',
		);
		
		foreach ($dirs as $dir) {
			if (file_exists("${dir}/Resque.php")) {
				$RESQUE_PATH = $dir;
				break;
			}
		}
		
		if(!$RESQUE_PATH) {
			die(
				'You need to set up the project dependencies using the following commands:' . PHP_EOL .
				'	curl -s http://getcomposer.org/installer | php' . PHP_EOL .
				'	php composer.phar install' . PHP_EOL .
				'or by defining RESQUE_PATH as an environment variable pointing to the directory where PHP-Resque is installed/cloned.' . PHP_EOL
			);
		}
	}
	
	// Preserve existing autoloader, if any
	if ( ( spl_autoload_functions() === FALSE) && function_exists('__autoload') )
	{
		spl_autoload_register('__autoload');
	}
	// Register fallback autoloader, which isn't as elegant as Composer's, but removes the dependency thereon
	spl_autoload_register(function($class) {
		$path = $GLOBALS["RESQUE_PATH"] . DIRECTORY_SEPARATOR . str_replace(array('_', '\\', '/'), DIRECTORY_SEPARATOR, $class) . ".php";
		
		if(file_exists($path)) {
			require_once($path);
		}
	});
}

$QUEUE = getenv('QUEUE');
if(empty($QUEUE)) {
    die("Set QUEUE env var containing the list of queues to work.\n");
}

$REDIS_BACKEND = getenv('REDIS_BACKEND');
$REDIS_BACKEND_DB = getenv('REDIS_BACKEND_DB');
if(!empty($REDIS_BACKEND)) {
    if (empty($REDIS_BACKEND_DB))
        Resque::setBackend($REDIS_BACKEND);
    else
        Resque::setBackend($REDIS_BACKEND, $REDIS_BACKEND_DB);
}

$logLevel = false;
$LOGGING = getenv('LOGGING');
$VERBOSE = getenv('VERBOSE');
$VVERBOSE = getenv('VVERBOSE');
if(!empty($LOGGING) || !empty($VERBOSE)) {
    $logLevel = true;
}
else if(!empty($VVERBOSE)) {
    $logLevel = true;
}

$APP_INCLUDE = getenv('APP_INCLUDE');
if($APP_INCLUDE) {
    if(!file_exists($APP_INCLUDE)) {
        die('APP_INCLUDE ('.$APP_INCLUDE.") does not exist.\n");
    }

    require_once $APP_INCLUDE;
}

// See if the APP_INCLUDE containes a logger object,
// If none exists, fallback to internal logger
if (!isset($logger) && !is_object(@$logger)) {
    $logger = new Resque_Log($logLevel);
}

$BLOCKING = getenv('BLOCKING') !== FALSE;

$interval = 5;
$INTERVAL = getenv('INTERVAL');
if(!empty($INTERVAL)) {
    $interval = $INTERVAL;
}

$count = 1;
$COUNT = getenv('COUNT');
if(!empty($COUNT) && $COUNT > 1) {
    $count = $COUNT;
}

$PREFIX = getenv('PREFIX');
if(!empty($PREFIX)) {
    $logger->log(Psr\Log\LogLevel::INFO, 'Prefix set to {prefix}', array('prefix' => $PREFIX));
    Resque_Redis::prefix($PREFIX);
}

if($count > 1) {
    for($i = 0; $i < $count; ++$i) {
        $pid = Resque::fork();
        if($pid == -1) {
            $logger->log(Psr\Log\LogLevel::EMERGENCY, 'Could not fork worker {count}', array('count' => $i));
            die();
        }
        // Child, start the worker
        else if(!$pid) {
            $queues = explode(',', $QUEUE);
            $worker = new Resque_Worker($queues);
            $worker->setLogger($logger);
            $logger->log(Psr\Log\LogLevel::NOTICE, 'Starting worker {worker}', array('worker' => $worker));
            $worker->work($interval, $BLOCKING);
            break;
        }
    }
}
// Start a single worker
else {
    $queues = explode(',', $QUEUE);
    $worker = new Resque_Worker($queues);
    $worker->setLogger($logger);

    $PIDFILE = getenv('PIDFILE');
    if ($PIDFILE) {
        file_put_contents($PIDFILE, getmypid()) or
            die('Could not write PID information to ' . $PIDFILE);
    }

    $logger->log(Psr\Log\LogLevel::NOTICE, 'Starting worker {worker}', array('worker' => $worker));
    $worker->work($interval, $BLOCKING);
}

/* End Of File bin/resque */